{"version":3,"file":"util.js","sources":["uni_modules/wot-design-uni/components/common/util.ts"],"sourcesContent":["import { AbortablePromise } from './AbortablePromise'\n\ntype NotUndefined<T> = T extends undefined ? never : T\n\n/**\n * 生成uuid\n * @returns string\n */\nexport function uuid() {\n  return s4() + s4() + s4() + s4() + s4() + s4() + s4() + s4()\n}\n\nfunction s4() {\n  return Math.floor((1 + Math.random()) * 0x10000)\n    .toString(16)\n    .substring(1)\n}\n\n/**\n * @description 对num自动填充px\n * @param {Number} num\n * @return {string} num+px\n */\nexport function addUnit(num: number | string) {\n  return Number.isNaN(Number(num)) ? `${num}` : `${num}px`\n}\n\n/**\n * @description 判断target是否对象\n * @param value\n * @return {boolean}\n */\nexport function isObj(value: any): value is object {\n  return Object.prototype.toString.call(value) === '[object Object]' || typeof value === 'object'\n}\n\n/**\n * 获取目标原始类型\n * @param target 任意类型\n * @returns {string} type 数据类型\n */\nexport function getType(target: unknown): string {\n  // 得到原生类型\n  const typeStr = Object.prototype.toString.call(target)\n  // 拿到类型值\n  const match = typeStr.match(/\\[object (\\w+)\\]/)\n  const type = match && match.length ? match[1].toLowerCase() : ''\n  // 类型值转小写并返回\n  return type\n}\n\n/**\n * @description 默认的外部格式化函数 - picker 组件\n * @param items - 要格式化的数据项数组或单个数据项\n * @param kv - 配置对象，包含 labelKey 作为键值\n * @returns 格式化后的字符串\n */\nexport const defaultDisplayFormat = function (items: any[] | Record<string, any>, kv?: { labelKey?: string }): string {\n  const labelKey: string = kv?.labelKey || 'value'\n\n  if (Array.isArray(items)) {\n    return items.map((item) => item[labelKey]).join(', ')\n  } else {\n    return items[labelKey]\n  }\n}\n\n/**\n * @description 默认函数占位符 - pickerView组件\n * @param value 值\n * @return value\n */\nexport const defaultFunction = <T>(value: T): T => value\n\n/**\n * @description 检查值是否不为空\n * @param value 值\n * @return {Boolean} 是否不为空\n */\nexport const isDef = <T>(value: T): value is NonNullable<T> => value !== undefined && value !== null\n\n/**\n * @description 防止数字小于零\n * @param {number} num\n * @param {string} label 标签\n */\nexport const checkNumRange = (num: number, label: string = 'value'): void => {\n  if (num < 0) {\n    throw new Error(`${label} shouldn't be less than zero`)\n  }\n}\n\n/**\n * @description 防止 pixel 无意义\n * @param {number} num\n * @param {string} label 标签\n */\nexport const checkPixelRange = (num: number, label: string = 'value'): void => {\n  if (num <= 0) {\n    throw new Error(`${label} should be greater than zero`)\n  }\n}\n\n/**\n * 将 RGB 值转换为十六进制颜色代码。\n * @param {number} r - 红色分量 (0-255)。\n * @param {number} g - 绿色分量 (0-255)。\n * @param {number} b - 蓝色分量 (0-255)。\n * @returns {string} 十六进制颜色代码 (#RRGGBB)。\n */\nexport function rgbToHex(r: number, g: number, b: number): string {\n  // 将 RGB 分量组合成一个十六进制数。\n  const hex = ((r << 16) | (g << 8) | b).toString(16)\n\n  // 使用零填充十六进制数，确保它有 6 位数字（RGB 范围）。\n  const paddedHex = '#' + '0'.repeat(Math.max(0, 6 - hex.length)) + hex\n\n  return paddedHex\n}\n\n/**\n * 将十六进制颜色代码转换为 RGB 颜色数组。\n * @param hex 十六进制颜色代码（例如：'#RRGGBB'）\n * @returns 包含红、绿、蓝三个颜色分量的数组\n */\nfunction hexToRgb(hex: string): number[] {\n  const rgb: number[] = []\n\n  // 从第一个字符开始，每两个字符代表一个颜色分量\n  for (let i = 1; i < 7; i += 2) {\n    // 将两个字符的十六进制转换为十进制，并添加到 rgb 数组中\n    rgb.push(parseInt('0x' + hex.slice(i, i + 2), 16))\n  }\n\n  return rgb\n}\n\n/**\n * 计算渐变色的中间变量数组。\n * @param {string} startColor 开始颜色\n * @param {string} endColor 结束颜色\n * @param {number} step 获取渲染位置，默认为中间位置\n * @returns {string[]} 渐变色中间颜色变量数组\n */\nexport const gradient = (startColor: string, endColor: string, step: number = 2): string[] => {\n  // 将hex转换为rgb\n  const sColor: number[] = hexToRgb(startColor)\n  const eColor: number[] = hexToRgb(endColor)\n\n  // 计算R\\G\\B每一步的差值\n  const rStep: number = (eColor[0] - sColor[0]) / step\n  const gStep: number = (eColor[1] - sColor[1]) / step\n  const bStep: number = (eColor[2] - sColor[2]) / step\n\n  const gradientColorArr: string[] = []\n  for (let i = 0; i < step; i++) {\n    // 计算每一步的hex值\n    gradientColorArr.push(\n      rgbToHex(parseInt(String(rStep * i + sColor[0])), parseInt(String(gStep * i + sColor[1])), parseInt(String(bStep * i + sColor[2])))\n    )\n  }\n  return gradientColorArr\n}\n\n/**\n * 确保数值不超出指定范围。\n * @param {number} num 要限制范围的数值\n * @param {number} min 最小范围\n * @param {number} max 最大范围\n * @returns {number} 在指定范围内的数值\n */\nexport const range = (num: number, min: number, max: number): number => {\n  // 使用 Math.min 和 Math.max 保证 num 不会超出指定范围\n  return Math.min(Math.max(num, min), max)\n}\n\n/**\n * 比较两个值是否相等。\n * @param {any} value1 第一个值\n * @param {any} value2 第二个值\n * @returns {boolean} 如果值相等则为 true，否则为 false\n */\nexport const isEqual = (value1: any, value2: any): boolean => {\n  // 使用严格相等运算符比较值是否相等\n  if (value1 === value2) {\n    return true\n  }\n\n  // 如果其中一个值不是数组，则认为值不相等\n  if (!Array.isArray(value1) || !Array.isArray(value2)) {\n    return false\n  }\n\n  // 如果数组长度不相等，则认为值不相等\n  if (value1.length !== value2.length) {\n    return false\n  }\n\n  // 逐个比较数组元素是否相等\n  for (let i = 0; i < value1.length; ++i) {\n    if (value1[i] !== value2[i]) {\n      return false\n    }\n  }\n\n  // 所有比较均通过，则认为值相等\n  return true\n}\n\n/**\n * 在数字前补零，使其达到指定长度。\n * @param {number | string} number 要补零的数字\n * @param {number} length 目标长度，默认为 2\n * @returns {string} 补零后的结果\n */\nexport const padZero = (number: number | string, length: number = 2): string => {\n  // 将输入转换为字符串\n  let numStr: string = number.toString()\n\n  // 在数字前补零，直到达到指定长度\n  while (numStr.length < length) {\n    numStr = '0' + numStr\n  }\n\n  return numStr\n}\n\n/** @description 全局变量id */\nexport const context = {\n  id: 1000\n}\n\nexport type RectResultType<T extends boolean> = T extends true ? UniApp.NodeInfo[] : UniApp.NodeInfo\n\n/**\n * 获取节点信息\n * @param selector 节点选择器 #id,.class\n * @param all 是否返回所有 selector 对应的节点\n * @param scope 作用域（支付宝小程序无效）\n * @param useFields 是否使用 fields 方法获取节点信息\n * @returns 节点信息或节点信息数组\n */\nexport function getRect<T extends boolean>(selector: string, all: T, scope?: any, useFields?: boolean): Promise<RectResultType<T>> {\n  return new Promise<RectResultType<T>>((resolve, reject) => {\n    let query: UniNamespace.SelectorQuery | null = null\n    if (scope) {\n      query = uni.createSelectorQuery().in(scope)\n    } else {\n      query = uni.createSelectorQuery()\n    }\n\n    const method = all ? 'selectAll' : 'select'\n\n    const callback = (rect: UniApp.NodeInfo | UniApp.NodeInfo[]) => {\n      if (all && isArray(rect) && rect.length > 0) {\n        resolve(rect as RectResultType<T>)\n      } else if (!all && rect) {\n        resolve(rect as RectResultType<T>)\n      } else {\n        reject(new Error('No nodes found'))\n      }\n    }\n\n    if (useFields) {\n      query[method](selector).fields({ size: true, node: true }, callback).exec()\n    } else {\n      query[method](selector).boundingClientRect(callback).exec()\n    }\n  })\n}\n\n/**\n * 将驼峰命名转换为短横线命名。\n * @param {string} word 待转换的词条\n * @returns {string} 转换后的结果\n */\nexport function kebabCase(word: string): string {\n  // 使用正则表达式匹配所有大写字母，并在前面加上短横线，然后转换为小写\n  const newWord: string = word\n    .replace(/[A-Z]/g, function (match) {\n      return '-' + match\n    })\n    .toLowerCase()\n\n  return newWord\n}\n\n/**\n * 将短横线链接转换为驼峰命名\n * @param word 需要转换的短横线链接\n * @returns 转换后的驼峰命名字符串\n */\nexport function camelCase(word: string): string {\n  return word.replace(/-(\\w)/g, (_, c) => c.toUpperCase())\n}\n\n/**\n * 检查给定值是否为数组。\n * @param {any} value 要检查的值\n * @returns {boolean} 如果是数组则返回 true，否则返回 false\n */\nexport function isArray(value: any): value is Array<any> {\n  // 如果 Array.isArray 函数可用，直接使用该函数检查\n  if (typeof Array.isArray === 'function') {\n    return Array.isArray(value)\n  }\n  // 否则，使用对象原型的 toString 方法进行检查\n  return Object.prototype.toString.call(value) === '[object Array]'\n}\n\n/**\n * 检查给定值是否为函数。\n * @param {any} value 要检查的值\n * @returns {boolean} 如果是函数则返回 true，否则返回 false\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function isFunction<T extends Function>(value: any): value is T {\n  return getType(value) === 'function' || getType(value) === 'asyncfunction'\n}\n\n/**\n * 检查给定值是否为字符串。\n * @param {unknown} value 要检查的值\n * @returns {value is string} 如果是字符串则返回 true，否则返回 false\n */\nexport function isString(value: unknown): value is string {\n  return getType(value) === 'string'\n}\n\n/**\n * 否是数值\n * @param {*} value\n */\nexport function isNumber(value: any): value is number {\n  return getType(value) === 'number'\n}\n\n/**\n * 检查给定值是否为 Promise 对象。\n * @param {unknown} value 要检查的值\n * @returns {value is Promise<any>} 如果是 Promise 对象则返回 true，否则返回 false\n */\nexport function isPromise(value: unknown): value is Promise<any> {\n  // 先将 value 断言为 object 类型\n  if (isObj(value) && isDef(value)) {\n    // 然后进一步检查 value 是否具有 then 和 catch 方法，并且它们是函数类型\n    return isFunction((value as Promise<any>).then) && isFunction((value as Promise<any>).catch)\n  }\n  return false // 如果 value 不是对象类型，则肯定不是 Promise\n}\n\n/**\n * 检查给定的值是否为布尔类型\n * @param value 要检查的值\n * @returns 如果值为布尔类型，则返回true，否则返回false\n */\nexport function isBoolean(value: any): value is boolean {\n  return typeof value === 'boolean'\n}\n\nexport function isUndefined(value: any): value is undefined {\n  return typeof value === 'undefined'\n}\n\nexport function isNotUndefined<T>(value: T): value is NotUndefined<T> {\n  return !isUndefined(value)\n}\n\n/**\n * 检查给定的值是否为奇数\n * @param value 要检查的值\n * @returns\n */\nexport function isOdd(value: number): boolean {\n  if (typeof value !== 'number') {\n    throw new Error('输入必须为数字')\n  }\n\n  // 使用取模运算符来判断是否为奇数\n  // 如果 number 除以 2 的余数为 1，就是奇数\n  // 否则是偶数\n  return value % 2 === 1\n}\n\n/**\n * 是否为base64图片\n * @param {string} url\n * @return\n */\nexport function isBase64Image(url: string) {\n  // 使用正则表达式检查URL是否以\"data:image\"开头，这是Base64图片的常见前缀\n  return /^data:image\\/(png|jpg|jpeg|gif|bmp);base64,/.test(url)\n}\n\n/**\n * 将外部传入的样式格式化为可读的 CSS 样式。\n * @param {object | object[]} styles 外部传入的样式对象或数组\n * @returns {string} 格式化后的 CSS 样式字符串\n */\nexport function objToStyle(styles: Record<string, any> | Record<string, any>[]): string {\n  // 如果 styles 是数组类型\n  if (isArray(styles)) {\n    // 使用过滤函数去除空值和 null 值的元素\n    // 对每个非空元素递归调用 objToStyle，然后通过分号连接\n    return styles\n      .filter(function (item) {\n        return item != null && item !== ''\n      })\n      .map(function (item) {\n        return objToStyle(item)\n      })\n      .join(';')\n  }\n\n  if (isString(styles)) {\n    return styles\n  }\n\n  // 如果 styles 是对象类型\n  if (isObj(styles)) {\n    // 使用 Object.keys 获取所有属性名\n    // 使用过滤函数去除值为 null 或空字符串的属性\n    // 对每个属性名和属性值进行格式化，通过分号连接\n    return Object.keys(styles)\n      .filter(function (key) {\n        return styles[key] != null && styles[key] !== ''\n      })\n      .map(function (key) {\n        // 使用 kebabCase 函数将属性名转换为 kebab-case 格式\n        // 将属性名和属性值格式化为 CSS 样式的键值对\n        return [kebabCase(key), styles[key]].join(':')\n      })\n      .join(';')\n  }\n  // 如果 styles 不是对象也不是数组，则直接返回\n  return ''\n}\n\nexport const requestAnimationFrame = (cb = () => {}) => {\n  return new AbortablePromise((resolve) => {\n    const timer = setInterval(() => {\n      clearInterval(timer)\n      resolve(true)\n      cb()\n    }, 1000 / 30)\n  })\n}\n\n/**\n * 暂停指定时间函数\n * @param ms 延迟时间\n * @returns\n */\nexport const pause = (ms: number = 1000 / 30) => {\n  return new AbortablePromise((resolve) => {\n    const timer = setTimeout(() => {\n      clearTimeout(timer)\n      resolve(true)\n    }, ms)\n  })\n}\n\n/**\n * 深拷贝函数，用于将对象进行完整复制。\n * @param obj 要深拷贝的对象\n * @param cache 用于缓存已复制的对象，防止循环引用\n * @returns 深拷贝后的对象副本\n */\nexport function deepClone<T>(obj: T, cache: Map<any, any> = new Map()): T {\n  // 如果对象为 null 或或者不是对象类型，则直接返回该对象\n  if (obj === null || typeof obj !== 'object') {\n    return obj\n  }\n\n  // 处理特殊对象类型：日期、正则表达式、错误对象\n  if (isDate(obj)) {\n    return new Date(obj.getTime()) as any\n  }\n  if (obj instanceof RegExp) {\n    return new RegExp(obj.source, obj.flags) as any\n  }\n  if (obj instanceof Error) {\n    const errorCopy = new Error(obj.message) as any\n    errorCopy.stack = obj.stack\n    return errorCopy\n  }\n\n  // 检查缓存中是否已存在该对象的复制\n  if (cache.has(obj)) {\n    return cache.get(obj)\n  }\n\n  // 根据原始对象的类型创建对应的空对象或数组\n  const copy: any = Array.isArray(obj) ? [] : {}\n\n  // 将当前对象添加到缓存中\n  cache.set(obj, copy)\n\n  // 递归地深拷贝对象的每个属性\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      copy[key] = deepClone(obj[key], cache)\n    }\n  }\n\n  return copy as T\n}\n\n/**\n * 深度合并两个对象。\n * @param target 目标对象，将合并的结果存放在此对象中\n * @param source 源对象，要合并到目标对象的对象\n * @returns 合并后的目标对象\n */\nexport function deepMerge<T extends Record<string, any>>(target: T, source: Record<string, any>): T {\n  // 深拷贝目标对象，避免修改原始对象\n  target = deepClone(target)\n\n  // 检查目标和源是否都是对象类型\n  if (typeof target !== 'object' || typeof source !== 'object') {\n    throw new Error('Both target and source must be objects.')\n  }\n\n  // 遍历源对象的属性\n  for (const prop in source) {\n    // eslint-disable-next-line no-prototype-builtins\n    if (!source.hasOwnProperty(prop))\n      continue\n      // 使用类型断言，告诉 TypeScript 这是有效的属性\n    ;(target as Record<string, any>)[prop] = source[prop]\n  }\n\n  return target\n}\n\n/**\n * 深度合并两个对象。\n * @param target\n * @param source\n * @returns\n */\nexport function deepAssign(target: Record<string, any>, source: Record<string, any>): Record<string, any> {\n  Object.keys(source).forEach((key) => {\n    const targetValue = target[key]\n    const newObjValue = source[key]\n    if (isObj(targetValue) && isObj(newObjValue)) {\n      deepAssign(targetValue, newObjValue)\n    } else {\n      target[key] = newObjValue\n    }\n  })\n  return target\n}\n\n/**\n * 构建带参数的URL\n * @param baseUrl 基础URL\n * @param params 参数对象，键值对表示要添加到URL的参数\n * @returns 返回带有参数的URL\n */\nexport function buildUrlWithParams(baseUrl: string, params: Record<string, string>) {\n  // 将参数对象转换为查询字符串\n  const queryString = Object.entries(params)\n    .map(([key, value]) => `${key}=${encodeURIComponent(value)}`)\n    .join('&')\n\n  // 检查基础URL是否已包含查询字符串，并选择适当的分隔符\n  const separator = baseUrl.includes('?') ? '&' : '?'\n\n  // 返回带有参数的URL\n  return `${baseUrl}${separator}${queryString}`\n}\n\ntype DebounceOptions = {\n  leading?: boolean // 是否在延迟时间开始时调用函数\n  trailing?: boolean // 是否在延迟时间结束时调用函数\n}\n\nexport function debounce<T extends (...args: any[]) => any>(func: T, wait: number, options: DebounceOptions = {}): T {\n  let timeoutId: ReturnType<typeof setTimeout> | null = null\n  let lastArgs: any[] | undefined\n  let lastThis: any\n  let result: ReturnType<T> | undefined\n  const leading = isDef(options.leading) ? options.leading : false\n  const trailing = isDef(options.trailing) ? options.trailing : true\n\n  function invokeFunc() {\n    if (lastArgs !== undefined) {\n      result = func.apply(lastThis, lastArgs)\n      lastArgs = undefined\n    }\n  }\n\n  function startTimer() {\n    timeoutId = setTimeout(() => {\n      timeoutId = null\n      if (trailing) {\n        invokeFunc()\n      }\n    }, wait)\n  }\n\n  function cancelTimer() {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId)\n      timeoutId = null\n    }\n  }\n\n  function debounced(this: any, ...args: Parameters<T>): ReturnType<T> | undefined {\n    lastArgs = args\n    lastThis = this\n\n    if (timeoutId === null) {\n      if (leading) {\n        invokeFunc()\n      }\n      startTimer()\n    } else if (trailing) {\n      cancelTimer()\n      startTimer()\n    }\n\n    return result\n  }\n\n  return debounced as T\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function throttle(func: Function, wait: number): Function {\n  let timeout: ReturnType<typeof setTimeout> | null = null\n  let previous: number = 0\n\n  const throttled = function (this: any, ...args: any[]) {\n    const now = Date.now()\n    const remaining = wait - (now - previous)\n\n    if (remaining <= 0) {\n      if (timeout) {\n        clearTimeout(timeout)\n        timeout = null\n      }\n      previous = now\n      func.apply(this, args)\n    } else if (!timeout) {\n      timeout = setTimeout(() => {\n        previous = Date.now()\n        timeout = null\n        func.apply(this, args)\n      }, remaining)\n    }\n  }\n\n  return throttled\n}\n\n/**\n * 根据属性路径获取对象中的属性值\n * @param obj 目标对象\n * @param path 属性路径，可以是字符串或字符串数组\n * @returns 属性值，如果属性不存在或中间的属性为 null 或 undefined，则返回 undefined\n */\nexport const getPropByPath = (obj: any, path: string): any => {\n  const keys: string[] = path.split('.')\n\n  try {\n    return keys.reduce((acc: any, key: string) => (acc !== undefined && acc !== null ? acc[key] : undefined), obj)\n  } catch (error) {\n    return undefined\n  }\n}\n\n/**\n * 检查一个值是否为Date类型\n * @param val 要检查的值\n * @returns 如果值是Date类型，则返回true，否则返回false\n */\nexport const isDate = (val: unknown): val is Date => Object.prototype.toString.call(val) === '[object Date]' && !Number.isNaN((val as Date).getTime())\n\n/**\n * 检查提供的URL是否为视频链接。\n * @param url 需要检查的URL字符串。\n * @returns 返回一个布尔值，如果URL是视频链接则为true，否则为false。\n */\nexport function isVideoUrl(url: string): boolean {\n  // 使用正则表达式匹配视频文件类型的URL\n  const videoRegex = /\\.(mp4|mpg|mpeg|dat|asf|avi|rm|rmvb|mov|wmv|flv|mkv|video)/i\n  return videoRegex.test(url)\n}\n\n/**\n * 检查提供的URL是否为图片URL。\n * @param url 待检查的URL字符串。\n * @returns 返回一个布尔值，如果URL是图片格式，则为true；否则为false。\n */\nexport function isImageUrl(url: string): boolean {\n  // 使用正则表达式匹配图片URL\n  const imageRegex = /\\.(jpeg|jpg|gif|png|svg|webp|jfif|bmp|dpg|image)/i\n  return imageRegex.test(url)\n}\n\n/**\n * 判断环境是否是H5\n */\nexport const isH5 = (() => {\n  let isH5 = false\n  // #ifdef H5\n  isH5 = true\n  // #endif\n  return isH5\n})()\n\n/**\n * 剔除对象中的某些属性\n * @param obj\n * @param predicate\n * @returns\n */\nexport function omitBy<O extends Record<string, any>>(obj: O, predicate: (value: any, key: keyof O) => boolean): Partial<O> {\n  const newObj = deepClone(obj)\n  Object.keys(newObj).forEach((key) => predicate(newObj[key], key) && delete newObj[key]) // 遍历对象的键，删除值为不满足predicate的字段\n  return newObj\n}\n\n/**\n * 缓动函数，用于在动画或过渡效果中根据时间参数计算当前值\n * @param t 当前时间，通常是从动画开始经过的时间\n * @param b 初始值，动画属性的初始值\n * @param c 变化量，动画属性的目标值与初始值的差值\n * @param d 持续时间，动画持续的总时间长度\n * @returns 计算出的当前值\n */\nexport function easingFn(t: number = 0, b: number = 0, c: number = 0, d: number = 0): number {\n  return (c * (-Math.pow(2, (-10 * t) / d) + 1) * 1024) / 1023 + b\n}\n\n/**\n * 从数组中寻找最接近目标值的元素\n *\n * @param arr 数组\n * @param target 目标值\n * @returns 最接近目标值的元素\n */\nexport function closest(arr: number[], target: number) {\n  return arr.reduce((prev, curr) => (Math.abs(curr - target) < Math.abs(prev - target) ? curr : prev))\n}\n"],"names":["uni","AbortablePromise"],"mappings":"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"}